
//  constants related to the Arduino Nano pin use
const int clkIn = 2;           // the digital (clock) input
const int digPin[2] = {3, 4};  // the digital output pins
const int pinOffset = 5;       // the first DAC pin (from 5-12)
const int trigTime = 25;       // 25 ms trigger timing

//  variables for interrupt handling of the clock input
volatile int clkState = LOW;

//  variables used to control the current DIO output states
int digState[2] = {LOW, LOW};        // start with both set low
unsigned long digMilli[2] = {0, 0};  // a place to store millis()

// for the on/off switch on clock in
int inputIsHigh = 0;

int probabilitySwitch = 0;

// for the calculation of distances between "clock highs"
long time;
long halfTime;
long oldTime = 0;

int currentchordValue = 0;
int previousNote = 98;

int place;
const int noOfplaces = 9;

int patternPlayLength = 16;

int previousPatternPlace;

const int noOfPatterns = 8; // plus one here if a pattern is added to "pattern"

const int patternLength = 16;
int patternValue;
int patternType;
int patternTypeUtility = 1023 / noOfPatterns;
int patternPlace = 0;
int pattern[noOfPatterns][patternLength] = {
  
  // | 5 A    || 6 A# | 7 B  | 8 C | 9 C# |10 D |11 D# | 12 |
  // | 0 E    || 1 F  | 2 F# | 3 G | 4 G# | 5 A | 6 A# | 7  |
  
  // 1,  2,  3,  4,  5,  6,  7,  8,    1,  2,  3,  4,  5,  6,  7,  8
    {0,  1,  2,  3,  4,  5,  6,  7,    0,  1,  2,  3,  4,  5,  6,  7},  
    {0,  7,  10, 7,  9,  5,  7,  3,    0,  7,  10, 7,  9,  5,  7,  3},  
    {0,  1,  0,  2,  0,  3,  0,  4,    0,  1,  0,  2,  0,  3,  0,  4},  
    {0,  2,  3,  3,  7,  3,  5,  5,    0,  2,  3,  3,  7,  3,  5,  5},  
    {0,  8,  7,  5,  3,  5,  7, 10,    0,  8,  7,  5,  3,  5,  7, 10}, // 12 o clock  
    {0,  10, 0,  8,  0,  7,  3,  5,    0,  10, 0,  8,  0,  7,  3,  5},    
    {0,  7,  3,  0,  9,  5,  9,  10,   0,  7,  3,  0,  9,  5,  9, 10},
    
    {0,  0,  0,  0,  0,  0,  0,  0,    0,  0,  0,  0,  0,  0,  0,  0},     
};

int c     = 1;      int c2     = 13;     int c3     = 25;     int c4     = 37;
int ciss  = 2;      int ciss2  = 14;     int ciss3  = 26;     int ciss4  = 38;
int d     = 3;      int d2     = 15;     int d3     = 27;     int d4     = 39;
int diss  = 4;      int diss2  = 16;     int diss3  = 28;     int diss4  = 40;
int e     = 5;      int e2     = 17;     int e3     = 29;     int e4     = 41;
int f     = 6;      int f2     = 18;     int f3     = 30;     int f4     = 42;
int fiss  = 7;      int fiss2  = 19;     int fiss3  = 31;     int fiss4  = 43;
int g     = 8;      int g2     = 20;     int g3     = 32;     int g4     = 44;
int giss  = 9;      int giss2  = 21;     int giss3  = 33;     int giss4  = 45;
int a     = 10;     int a2     = 22;     int a3     = 34;     int a4     = 46;
int aiss  = 11;     int aiss2  = 23;     int aiss3  = 35;     int aiss4  = 47;
int b     = 12;     int b2     = 24;     int b3     = 36;     int b4     = 48;

int chord;
int oldChord;
const int noOfchords = 12;
const int chordLength = 15;
int chordUtility = 1023 / noOfchords;
int chords[noOfchords][noOfplaces] = {
  
  // patternType steps through from top to bottom
  
  // 0,    1,     2,      3,     4,     5,      6,     7,     8,   
  
    {e,    giss,  b,      e2,    giss2, b2,     e3,    giss3, b3    },      // E 
    {f,    a,     c2,     aiss2, ciss3, f3,     aiss3, ciss3, f4    },      // F    
    {fiss, aiss,  ciss2,  fiss2, aiss2, ciss3,  fiss3, aiss3, ciss4 },      // Fiss 
    {g,    b,     d2,     g2,    b2,    d3,     g3,    b3,    d4    },      // G
    {giss, c2,    d2,     giss2, c3,    d3,     giss3, c4,    d4    },      // Giss
    {a,    ciss2, e2,     a2,    ciss3, e3,     a3,    ciss4, e4    },      // A
    {aiss, d2,    f2,     aiss2, d3,    f3,     aiss3, d4,    f4    },      // Aiss
    {b,    diss2, fiss2,  b2,    diss3, fiss3,  b3,    diss4, fiss4 },      // B
    {c2,    e,     g,      c2,    e2,    g2,     c3,    e3,    g3    },      // C
    {ciss2, f,     giss,   ciss2, f2,    giss2,  ciss3, f3,    giss3 },      // Ciss
    {d2,    fiss,  a,      d2,    fiss2, a2,     d3,    fiss3, a3    },      // D
    {diss2, g,     aiss,   diss2, g2,    aiss2,  diss3, g3,    aiss3 },      // Diss




//    {e,    giss,  b,     99,    99,    e2,    giss2, b2,    99,    99,    e3,    giss3, b3,    99,     99},      // E 
//    {f,    a,     c2,    99,    99,    aiss2, ciss3, f3,    99,    99,    aiss3, ciss3, f4,    99,     99},      // F    
//    {fiss, aiss,  ciss2, 99,    99,    fiss2, aiss2, ciss3, 99,    99,    fiss3, aiss3, ciss4, 99,     99},      // Fiss 
//    {g,    b,     d2,    99,    99,    g2,    b2,    d3,    99,    99,    g3,    b3,    d4,    99,     99},      // G
//    {giss, c2,    d2,    99,    99,    giss2, c3,    d3,    99,    99,    giss3, c4,    d4,    99,     99},      // Giss
//    {a,    ciss2, e2,    99,    99,    a2,    ciss3, e3,    99,    99,    a3,    ciss4, e4,    99,     99},      // A
//    {aiss, d2,    f2,    99,    99,    aiss2, d3,    f3,    99,    99,    aiss3, d4,    f4,    99,     99},      // Aiss
//    {b,    diss2, fiss2, 99,    99,    b2,    diss3, fiss3, 99,    99,    b3,    diss4, fiss4, 99,     99},      // B
//    {c,    e,     g,     99,    99,    c2,    e2,    g2,    99,    99,    c3,    e3,    g3,    99,     99},      // C
//    {ciss, f,     giss,  99,    99,    ciss2, f2,    giss2, 99,    99,    ciss3, f3,    giss3, 99,     99},      // Ciss
//    {d,    fiss,  a,     99,    99,    d2,    fiss2, a2,    99,    99,    d3,    fiss3, a3,    99,     99},      // D
//    {diss, g,     aiss,  99,    99,    diss2, g2,    aiss2, 99,    99,    diss3, g3,    aiss3, 99,     99},      // Diss
    
//    {e,    g,     b,     99,    99,    e2,    g2,    b2,    99,    99,    e3,    g3,    b3,    99,     99},      // Em
//    {f,    giss,  c2,    99,    99,    f2,    giss2, c3,    99,    99,    f3,    giss3, c4,    99,     99},      // Fm
//    {fiss, a,     ciss2, 99,    99,    fiss2, a2,    ciss3, 99,    99,    fiss3, a3,    ciss4, 99,     99},      // Fissm  
//    {g,    aiss,  d2,    99,    99,    g2,    aiss2, d3,    99,    99,    g3,    aiss3, d4,    99,     99},      // Gm
//    {giss, b,     diss2, 99,    99,    giss2, b2,    diss3, 99,    99,    giss3, b3,    diss4, 99,     99},      // Gissm 
//    {a,    c2,    e2,    99,    99,    a2,    c3,    e3,    99,    99,    a3,    c4,    e4,    99,     99},      // Am
//    {aiss, ciss2, f2,    99,    99,    aiss2, ciss3, f3,    99,    99,    aiss3, ciss3, f4,    99,     99},      // Aissm
//    {b,    d2,    fiss2, 99,    99,    b2,    d3,    fiss3, 99,    99,    b3,    d4,    fiss4, 99,     99},      // Bm
//    {c,    diss,  g,     99,    99,    c2,    diss2, g2,    99,    99,    c3,    diss3, g3,    99,     99},      // Cm
//    {ciss, e,     giss,  99,    99,    ciss2, e2,    giss2, 99,    99,    ciss3, e3,    giss3, 99,     99},      // Cissm 
//    {d,    f,     a,     99,    99,    aiss2, ciss3, f3,    99,    99,    aiss3, ciss3, f4,    99,     99},      // Dm
//    {diss, fiss,  aiss,  99,    99,    diss2, fiss2, aiss2, 99,    99,    diss3, fiss3, aiss3, 99,     99},      // Dissm

};

////////////////////////////////////////////////////////

void setup() 
{
  Serial.begin(9600);

  pinMode(clkIn, INPUT);
  
  for (int i=0; i<2; i++) {
    pinMode(digPin[i], OUTPUT);
    digitalWrite(digPin[i], LOW);
  }
  
  for (int i=0; i<8; i++) {
    pinMode(pinOffset+i, OUTPUT);
    digitalWrite(pinOffset+i, LOW);
  }
  attachInterrupt(0, isr, RISING);
}


void setProbabilitySwitch() {   
      
}

////////////////////////////////////////////////////////

void loop() {

  
  
  
  
  
  
  
  if (analogRead(2) > 1) { // unlock patternPlace with A2 at 0. More than 0 and the A2 input will set the place in the scale list, instead of clock. A new note will set off a trigger.
    patternPlace = (analogRead(2) / (1023/patternLength)); if (patternLength > 0) {  patternPlace--; } // deal with zero indexing on addressing the array vs the integer declared to set the number.
    
    
    patternValue = pattern[patternType][patternPlace];    
    
    Serial.print("patternPlace "); Serial.println(patternPlace);
        Serial.print("previousPatternPlace "); Serial.println(previousPatternPlace);
//    Serial.print("chord"); Serial.println(chord);
//    Serial.print("place"); Serial.println(place);  
    
    // play
    int note = (((chords[patternValue][place]) * 4) + (12)); //    int note = (((chords[patternValue][place]) * 4) + (12 * 4));
    dacOutput(note);
    
    if (previousPatternPlace != patternPlace) {
      digitalWrite(digPin[0], HIGH);   
      digitalWrite(digPin[0], LOW);
    }
    
    previousPatternPlace = patternPlace;
  }
  

  
  
  
  
  // patternType sets the type of pattern to be played in the chord matrix. Patterns "jump" vertically through the current chord matrix column.
  //patternType = (analogRead(0) >> 5);   
  patternType = (analogRead(0) / (1023/noOfPatterns)); if (patternType > 0) {  chord--; } // deal with zero indexing on addressing the array vs the integer declared to set the number.

  // 9 steps x-axis 
  // place sets the column to be played in the chord matrix. different versions of the same chord.
  place = (analogRead(3) / (1023/noOfplaces)); if (place > 0) {  place--; } // deal with zero indexing on addressing the array vs the integer declared to set the number.
  
  // between 0 and 16 steps that the sequence will be able to play through. A1 sets the allowed lenght of the played pattern
  patternPlayLength = (analogRead(1) / (1023/patternLength)); if (patternPlayLength > 0) {  patternPlayLength--; } // deal with zero indexing on addressing the array vs the integer declared to set the number.

  if (clkState == HIGH) {
    clkState = LOW;
    
    // Gate high for D0 on each output signal
    digitalWrite(digPin[0], HIGH); digitalWrite(digPin[0], LOW);
    
    // patternValue is the current Y-axis place in the chord matrix. patternPlace advances by 1 for each loop.
    patternValue = pattern[patternType][patternPlace];    
    
    Serial.print("patternPlayLength"); Serial.println(patternPlayLength);
//    Serial.print("chord"); Serial.println(chord);
//    Serial.print("place"); Serial.println(place);  
    
    // play
    int note = (((chords[patternValue][place]) * 4) + (12)); //    int note = (((chords[patternValue][place]) * 4) + (12 * 4));
    dacOutput(note);

    
    // gate high for D1 only if the note changes from last time
    if (previousNote != note) {
      digitalWrite(digPin[1], HIGH);   
      digitalWrite(digPin[1], LOW);
    }
    
    previousNote = note;

    // advance one step in pattern
    patternPlace++;
                        

    
    // when the pattern has reached its final note in the pattern series
    if (patternPlace >= patternPlayLength ) {
      patternPlace = 0;

      } // pattern has reached its final note
  } // clock high ends
  
  
  
  
  
} // loop








void isr()
{
  clkState = HIGH;
}

void writeStep(boolean on){
    if(on){
        digitalWrite(digPin[0], HIGH);
        digitalWrite(digPin[1], LOW);
    }else{
        digitalWrite(digPin[0], LOW);
        digitalWrite(digPin[1], HIGH);
    }  
}

//  dacOutput(long) - deal with the DAC output
//  ------------------------------------------
void dacOutput(long v)
{
  // feed this routine a value between 0 and 255 and teh DAC
  // output will send it out.
  int tmpVal = v;
  for (int i=0; i<8; i++) {
    digitalWrite(pinOffset + i, tmpVal & 1);
    tmpVal = tmpVal >> 1;
  }
}
